{"./":{"url":"./","title":"关于本书","keywords":"","body":"关于本书-像编写javacript一样编写样式 相信很多童鞋在使用sass/scss(以下以及后面章节统称sass)的时候，应该大都对关于sass的使用大家应该经常用到的是它的变量以及嵌套使用规则吧！ 但其实对于sass整个知识体系，以及它的一个运用范围远不止这些，通过对官方的文档的学习，同时也整理了一些关于sass的使用最佳实践： 在小组件，小项目中，非必要情况下可以不考虑使用sass； 在使用sass变量的时候，尽可能地将变量声明放到统一的一个地方，而不是根据组件，到时定义变量，为了使用sass而sass； 任何的sass逻辑运算，应当有一定的规则要求，而不是任意的将无关紧要的元素使用逻辑运算强行结合起来； 如果项目中需要使用到sass来管控系统中的所有的颜色、尺寸、样式逻辑运算规则等资源，那么应该要像我们在编写业务系统代码一样，在项目一开始就搭建其使用框架，确定使用规范、流程，并整理好对应的框架文档，而不是任由项目团队成员直接按照自己意愿随意添加，导致后续项目没办法做到统一的维护管理！！！ 本书旨在对sass的一个使用学习，以及如何使用sass来更好地服务于我们的项目，提升自己对该技能点的理解与认知，最后则通过一个开源的三方框架(bootstrap)，来对学习到的sass知识进行实战学习！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-19 18:13:55 像编写Javacript一样来写样式-关于本书-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-关于本书"},"preface/readme.html":{"url":"preface/readme.html","title":"序言","keywords":"","body":"序言 在真正进入sass的学习领域之前，我习惯于咨询自己几个问题，来明确自己学习sass的一个目的以及方向，其实也是自己对于知识点的一个学习目的： 为什么要学习sass？sass有什么价值？如何使用sass？ 也就是使用黄金圈规则来阅读一个知识体系，同时也督促自己能够坚持继续阅读并掌握该知识点。 什么是sass 要理解什么是sass，我觉得应该要先理解什么以下一个场景： 🤔当我们编写的css代码越来越多，且有一些元素之间 复用机制，但又不能100%复用，而且样式与样式之间也又一定的关联性，css文件越来越复杂，导致后续css样式难以维护，容易牵一发而动全身！！ 那么针对上述👆这种场景，假如 一种语法机制，能够解决上面的问题的话，我们所编写的代码是否能够更加的简介而又很容易地维护呢？答案是肯定的，这也就是为什么sass的出现的原因了。 sass是一种样式文件的预处理器机制，能够将以.sass或者.scss文件转换成普通的css文件，且在编写sass文件的时候，可以借助于sass框架所提供的变量、嵌套、混入、函数、逻辑运算、函数调用等等的 语法特性，编写出更加容易维护、容易扩展、更加简洁干练的、富有\"变\"属性的css样式代码 在学习关于如何使用saas的过程中，采用其提供的一个node环境下的命令行来学习关于sass的一个知识点，通过一个个的示例demo，来加深对该知识点的一个理解。 首先先安装对应的脚本，这里假设咱们已经 node环境了，只需要安装对应的一个全局指令即可： sudo npm install sass -g 安装完成 后，执行一下脚本，将会输出其版本信息： 在本书 中，将会采用最原始的sass-cli终端命令，来验证每一个知识点的运行结果，借此来走进关于sass的一个引用，而关于该命令行的一个简单使用， 则是直接使用的以下命令来将.sass文件转换为.css文件 sass meta.scss meta.css 为什么要使用sass 要理解为什么要使用sass的话，我想应该需要先从sass可以给我们带来什么好处来入手 从这里开始，将会以编写具有逻辑运算的样式代码，利用代码之间的一个逻辑关系，来编写出更加具有逻辑关系、简洁干练的代码！！ 如何来使用sass 前面也已经提及到了，尽量不因为sass而使用sass，任何的一个框架，使用前与使用后必须要带来便利性，或者提升效率，否则，宁愿不使用框架，sass也是如此， 要学习如何使用sass，还是🉐️回归到其特性，理解每一个特性的用法以及使用场景，然后进行一个有机结合，一步一个脚印 地来完成每一次尝试，总结出对应的组合经验！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-27 08:35:51 像编写Javacript一样来写样式-序言-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-序言"},"syntax/readme.html":{"url":"syntax/readme.html","title":"语法知识","keywords":"","body":"语法知识 sass就是一个可以转换为普通css样式的样式语言，它允许我们使用变量、嵌套、混入、函数、模块化、数学运算、逻辑运算等等，且能够完全适配到css的语法。 sass有助于保持大型样式表的良好组织结构，使其更加易于在项目内部以及项目之间共享公共模块设计！！！ 这里:u6709:一个关键点需要记住是：sass是一个预处理语言，它将编写的样式+代码进行一个组合，然后编译生成目标css样式，这也就说明了样式与代码之间:u6709:一定的鸿沟，或者说是壁垒！！ sass与scss傻傻分不清 首先两者文件后缀名的不同，一个是.sass，一个是.scss，两者可以互相转换，但一般在正常项目迭代开发过程中，建议必须选择其中一种，来保持项目团队的整体统一性。 从这里我们可以看出关于sass与scss两者的一个简单区别，无非就是有无花括号的而已，而sass在编写上更加接近于css，且代码的阅读可读性较高，因此，后续将统一采用sass来编写我们的样式！！ sass的结构 与普通的css一样，大部分sass由正规的css样式键值对来组成，但是sass也包含了css所没有的的一些特殊属性在其中。 一般的，组成代码的基础元素是语句 + 表达式，sass也不例外！ 语句 sass样式表由一系列语句组成，语句按照一定的规则来组合称语句块，语句块由\"{}\"来包裹组成 语句类型 描述 通用语句 普通的sass语句，可以在任何地方被使用，像变量的定义、流程控制、调试语句 css语句 用于生产css样式，除了在@function中不能使用之外，其他地方都可使用 顶层语句 一般在其他样式文件定义的最上层位置定义，或者在嵌套的代码块顶部定义，可以是模块的加载、导入、混入的定义或者是函数的定义 表达式 表达式位于属性或者变量声明右侧的任何内容，每个表达式都会生成一个值，任何有效的css属性值也是一个sass表达式 表达式类型 描述 常量表达式 像编写代码时的常量定义，比如有Numbers、String、Colors、Boolean、null、List、Maps 操作表达式 ==、!=、+-*/、、>=、and、or、not、() 其他表达式 变量引用，函数调用，父类选择器，!important 注释 sass中的注释与js中的注释类似，包括单行注释(//)以及多行注释(/*/)，一般地，如果我们想要将注释也对应输出到css文件中的话， 则采用多行注释的方式。 在使用注释的时候，需要注意的一个地方，就是如果没有修改到sass代码，而只是修改了注释的话，要重新看对应的注释效果 的话，需要将结果文件删掉，或者是强制重新生成.css文件 在使用sass来编写样式库的时候，特别是作为公共的函数、混入、变量等方式提供给其他同事使用的时候，一定要编写对应的注释 文档，提升代码可读性，方便其他同事后续扩展，避免重复发明轮子。 开源的关于sassdoc帮助我们提供了关于如何生成精美的sass注释，详情可以参考链接SassDoc 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-29 08:56:10 像编写Javacript一样来写样式-语法知识-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-语法知识"},"style-rules/readme.html":{"url":"style-rules/readme.html","title":"样式规则","keywords":"","body":"样式规则 样式规则就是sass的基础，就像它们也是css的基础一样，通过选择某个选择器，给其定义它的一个样式效果！！ .button { padding: 3px 10px; font-size: 12px; border-radius: 3px; border: 1px solid #e1e4e8; } 嵌套 这也是使用sass经常用到的：嵌套，通过嵌套，我们可以不用从头到尾去编写关于不同位置的深层次的样式规则，而是简单的根据 目前html节点的嵌套规则，利用代码块符号()来将节点嵌套，从而生成我们所想要的结果，如下图所示: 如果我们编写的sass嵌套得很深的话，那么将会生成对应的很深层次的代码，而且代码量也会随之增加，而导致请求的*.css需要 消耗的带宽更大，因此，尽量编写是层次不会那么深的嵌套！！！ 列表嵌套 如果在编写嵌套的时候，使用了关于列表嵌套的机制，那么对应生成的*.css文件中的嵌套规则也将会是对应的笛卡尔组合的效果，如下图所示： 选择组合器 sass/css提供了选择组合器(>、+、~)，可以快速进行选择器的组合 父选择器 sass提供了一种特殊的选择器(&)，用于在嵌套的时候，指向父选择，从而可以在被嵌套中指向父选择器，比如有以下的例子： 从上面:point_up: 例子我们可以看出父选择器提供了一个跟父选择器相关的前后节点的快捷定义，从一定程度上减少了编写的代码量，代码更加干练 我们还可以在父选择器中给其🈯️定后缀，使其所关联的前后节点都带有一定的名称关联性，就无需自己去添加后缀来区分了，这尤其是在一些UI库框架中较为常见 在sass的逻辑运算脚本中，比如在函数或者是混入中使用(&)，代表的是当前上下文所在的外部父选择器，如果它没有外部选择器的话，那么它就返回为null，否则就返回外部选择器， 这可以很方便地使用if()三目运算符来进行逻辑true/false判断，并执行对应的语句，比如赋值等操作，如下代码所示： @mixin app-background($color){ #{if(&, '&.app-background', '.app-background')}{ background-color: $color; color: rgba(#000, 0.75); } } @include app-background(#036); .app{ @include app-background(#036); } 👆这里如果app-background被包裹的话，则&返回true，否则就返回false，因此会有两种不同的输出结果！！！ 插值 使用插值可以将变量和函数调用表达式中的值注入选择，在编写混入的时候特别游泳，因为通过这种方式，我们可以根据用户传入的参数来创建可根据参数进行变化的动态选择器 @mixin define-emoji($name, $glyph){ span.emoji-#{$name} { font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; font-variant: normal; font-weight: normal; content: $glyph; } } @include define-emoji(\"women-holding-hands\", \"two_women_holding_hands\"); 属性定义 sass除了跟css一样的属性定义元素的样式之外，还增加了额外的功能，比如声明的值可以是任何sassscript表达式，将表达式的值进行自动计算并存储在其结果中！！！ .circle{ $size: 100px; width: $size; height: $size; border-radius: $size * 0.5; } 在定义元素属性样式的时候，我们还可以使用插值来动态地生成我们所想要的属性的key，如下所示： @mixin prefix($property, $value, $prefixes){ @each $prefix in $prefixes{ -#{$prefix}-#{$property}: $value; } #{$property}: $value; } .gray{ @include prefix(filter, grayscale(50%), moz webkit); } 在平时编写css属性的时候，经常会 遇到同时属性前缀的情况，比如：background-color、background-image、background-size等等，而使用sass嵌套的时候，我们也可以利用这一个规则， 编写出简写的嵌套的sass样式表，需要做的仅仅是在外部添加一个可被css识别的前缀即可： .large{ font-size: 16px; transition: { property: font-size; duration: 4s; delay: 2s; } &:hover{ font-size: 20px; } } 有时，我们想要编写可直接隐藏的属性，借助于if()三目运算符，通过判断传递变量/上下文，false则相当于隐藏该属性： $radius: false; .button{ border: 1px solid black; border-radius: if($radius, 2px, null); } css中可以通过定义css变量，来作为公共的样式使用，而且可以在js中直接访问到这些值，而sass解析变量属性的时候，简单的直接原样地传递给css，唯一不同的就是可以通过插值来整！！！ $primary: #112233; $accent: #456734; $warn: #684050; :root{ --primary: #{$primary}; --accent: #{$accent}; --warn: #{$warn}; } 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-28 20:59:19 像编写Javacript一样来写样式-样式规则-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-样式规则"},"variables/readme.html":{"url":"variables/readme.html","title":"变量","keywords":"","body":"变量 sass中的变量以$开头，然后是字母+数字+符号来命名的，这里又一个特殊的需要mark一下的就是：中横线的变量与下横线的变量在sass范围内，属于是同一个变量！！ sass变量，作为sass领域内的重要价值的工具之一，解决了关于样式属性具有上下文关联动作的统一口径，比如可以定义全局主题色，通过修改变量的方式，可以编译出全局统一一个资源属性值的结果！ 定义与使用 $x: #123456; 变量的定义，只能是在样式代码块中定义，或者是在逻辑运算中定义，而且这里不同位置的定义，将会有不同的一个效果(值的覆盖使用) 与css变量的区别： sass变量是被与处理器编译输出最终目标样式的，而css变量则是原样输出; css变量在不同的节点中可以有不同的值，而sass变量则是每一次瞬间只能有唯一的一个值； css变量是全局共享的，一旦改变它的值，则会影响到全局所有的样式，而sass变量则是编译时生效，一旦改变它的值，则距离该变量最近以及后续的将会受到影响 可配置的默认值 这有点类似于ES6.0中的函数默认值，或者是对象结构的默认值一般，sass变量在声明时，可定义一默认值(通过使用!default)标识来配置，代表的是若无定义该变量的值，或者是null的时候，就使用当前变量的默认值， 同时当将其作为库共给其他sass文件使用时，可以使用针对该变量进行可行性配置动作，而对于库的使用，则一般是使用@rule library_name with (: )，传递进来的变量值，则将会替代原来的库中 的默认值 // _library.scss $black: #000 !default; $border-radius: 0.5rem !default; code{ border-radius: $border-radius; } // demo1.scss @use 'library' with ( $black: #222, $border-radius: 0.1rem ); 库中的常量 与可配置的默认值相对应的，如果没有设置了!default标识的话，那么该变量不允许被外部所改变，而是只能简单的直接访问而已，这有点类似于js中的const变量，一旦定义，就不能修改 @use \"sass:math\" as math; @debug math.$pi; // 以下将直接报错 math.$pi: 0; 作用域 与js中的变量作用域类似，sass变量也拥有同样类似的变量作用域效果，在某个模块中顶部位置所定义的变量，将会被模块应用者以及当前模块上下文可访问到(但这仅限于样式定义的变量) $global-variable: global value; .content{ $local-variable: local value; global: $global-variable; local: $local-variable; } .side{ global: $global-variable; } 这里使用的是不同名变量的在普通的样式属性代码中使用的变量，也是较常用的一种方式 全局作用域与局部作用域 🤔 这里如果我们使用的是局部样式中的变量与全局或者外部变量中的sass变量同名的话，这里又会发生怎样的一个情况呢？ 如下代码所示： $global-variable: global value; .content{ $global-variable: local value; global: $global-variable; } .side{ global: $global-variable; } 从上述编译结果我们可以看出，当样式属性中内部作用域下的变量与外部作用域下的变量同名时，样式属性中重新声明的变量将会当作是创建 当前样式属性作用域下的新变量并来使用该值！！！ 这里必须要强调的是样式属性代码下所形成的作用域，因为在下面:point_down:的由流程关键词所形成的流程作用域，将会使用的同一个sass变量， 具体看下面的介绍。 🤔假如我们一定要在样式属性代码中使用外层sass变量的话，是否可以做到呢？当然是可以的，我们可以通过标识符!global来对外层sass变量 进行一个引用，但这里 一个前提条件：样式代码中所重新定义的变量，必须在外层作用域范围内有效 流程作用域 通过使用@rule流程标识符所形成的基于逻辑代码层面所形成的代码流程作用域，比如通过使用@if、@while、@each等所形成的局部作用域， 这里与上面 的样式作用域下的变量 一个明显的区别，就是流程作用域下的sass变量与外层作用域的变量共享同一个变量，他们拥有公共的值，无需通过使用!global标识符 来设置访问同一个变量 $dark-theme: true !default; $primary-color: #f8bbd0 !default; $accent-color: #6a1b9a !default; @if $dark-theme { $primary-color: darken($primary-color, 60%); $accent-color: lighten($accent-color, 60%); } .button { background-color: $primary-color; border: 1px solid $accent-color; border-radius: 3px; } 那么这里为什么会 这样子的区别呢？-->样式作用域的 变量与流程作用域下的同一个变量！！ 因为这个 一个大前提条件：sass是一个预编译的语言，简单地理解，就是类似于js与css代码之间的一个边界，js代码肯定能够访问到作用域范围下的 同一个变量，这个是作用域变量的基本规则，而css则是在编译时，通过就近原则，访问到的变量来作为当前样式作用域下的 变量而已。 高级变量函数 sass提供了一对针对变量的函数 meta.variable-exists()：判断当前作用域下或者对象中是否存在这个某个变量的定义，若 定义则返回true，否则放回false meta.global-variable-exists()：与上述类似，只不过这里判断的是全局作用域下的 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-30 06:30:54 像编写Javacript一样来写样式-变量-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-变量"},"interpolation/readme.html":{"url":"interpolation/readme.html","title":"插值","keywords":"","body":"插值 sass中几乎到处都可以使用插值，这与ES6.0中的模版字符串有点类似，通过插值(使用标志符：#{变量/常量/表达式语句})，将插值语句的执行结果，输出到css样式中， 以下整理关于sass中插值可以使用的场景 样式代码中的选择器: .content-#{$name}{width: 20px} 样式属性名称: .content-name{border-#{propName}: 2px;} 样式属性值: .content-name{border-radius: #{$radius};} 艾特规则(@keyframes、@supports) @keyframe #{$name}{...} @extend: .content{ @extend .#{#name}-icon; } css中的import语句拼接: font: url('..#{$name}..') 字符串: 可以这么理解，上述的所有拼接都是字符串拼接的方式！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-01 05:03:21 像编写Javacript一样来写样式-插值-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-插值"},"at-rules/readme.html":{"url":"at-rules/readme.html","title":"\"艾特\"规则","keywords":"","body":"\"艾特\"规则 官方文档叫：@rules，个人给它起了一个名字，叫艾特规则，本书上均统一叫这个名字，方便自己记忆！ sass中的许多额外的功能，都是已艾特规则出现在css样式之上，一般是在最顶部，或者是在子作用域的顶部，反正就是顶部就是了。 sass提供了以下的艾特规则，如下图： 得益于艾特规则，我们可以使用很多具有逻辑运算能力的css，编写出更加干练、简洁的代码， 再也不用担心我只会编写出简单嵌套，重复冗余的css代码了！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-30 09:00:37 像编写Javacript一样来写样式-\"艾特\"规则-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-\"艾特\"规则"},"at-rules/at-use/readme.html":{"url":"at-rules/at-use/readme.html","title":"@use","keywords":"","body":"@use sass中的@use有点类似于ES6中的import关键词，主要用来加载其他sass样式文件中的mixin、function、variable，也可以用来加载普通的css文件，并对加载到的资源以及自身的资源进行组合，sass框架也提供了一些便捷的函数， 供我们直接通过@use来使用！@use的一个完整的语法规则： @use with (: , : ) as /* 针对 的参数进行对应的解释如下： library: 使用的sass库文件; with: 对于可配置的库而言，通过该关键词来进行参数的传递; (: ...): 要配置的自定义参数; as : 将引入的库用一个别名，也叫命名控件namespace来替代； as *: 将引入的库直接当作当前文件的变量来直接访问，无需进行添加库名.前缀； 如果没有使用as关键词的话，那么将默认使用目录的最后一个字符串来作为namespace，供后续访问使用。 在实际的编码过程中，如果将一个*.scss文件多次引入(@use)的话，那么在最终的输出时，只会被输出一次 // _code.scss $p: 10px; code { padding: .25em; line-height: 0; } // _list.scss @mixin name{ //... } ul, li{ text-align: center; } // demo1.scss @use 'code'; @use 'list'; 成员属性的加载 在通过使用@use来引入库资源之后，我们就可以通过.、.、.来访问库文件中的变量、混入、函数。 如下所示： @use 'code'; @use 'list'; .content{ padding: code.$p; @include list.name; } 而如果使用了as关键词来指向这个引用的库的话，那么可以如下： // 使用别名的场景 @use 'code' as myCode; .content{ padding: myCode.$p; } // 使用通配符的场景 @use 'list' as *; .content{ @include name; } 假如我们想要想java一样进行sass库中某些变量进行保护起来(类似于private以及protected)的话，那么我们可以使用sass它所提供的关于变量由public private：通过给变量在定义其名字的时候，在名字最前面添加一个-/_， 将成员给保护起来，这里的成员主要是指的变量、混入、函数！！如下所示： // _corner.scss $-radius: 3px; @mixin -private_round{ border-radius: $-radius; } @mixin public_round{ border-radius: $-radius; } // demo2.scss @use 'corner'; .button{ @include corner.public_round; // 以下语句将会报错，提示不能访问内部私有成员 padding: corner.$-radius; } 可配置参数的导入 在编写自己样式库时，我们可以通过标识符(!default)来告知该库中的某些变量是允许通过外部传入参数的方式来更改基础资源的，这让我们所编写的样式代码更加富有活力，灵活性更高 // _library.scss $x: 1px !default; $y: 2px !default; @mixin common-pad{ padding: #{$x} #{$y}; } // demo3.scss @use 'library' with ($x: 4px, $y:8px); .content{ @include library.common-pad; } 最佳实践 在实际的日常coding过程中，尽量采用两个mixin结合，来输入自己所想要的目标样式结果，什么意思呢 简单来说，就是整两个mixin，一个用来更改当前库中的变量，一个用来输出目标结果样式，这样子在使用到配置参数的时候，都可以获取到最新的配置，为什么要这样子做呢 这样子不是徒增代码量吗？其实思考一个问题就可以想到这样子写的好处：当代码量越来越多的时候，发现有变量到处都被改变了，可能会引起错误的效果，因为@use都是N次导入，一次输出的。 具体实践方案如下： // _library.scss $x: 1px !default; $y: 2px !default; @mixin changeXY($newX, $newY){ @if $newX{ $x: $newX !global; } @if $newY{ $y: $newY !global; } } @mixin common-pad{ padding: #{$x} #{$y}; } // demo4.scss @use 'library'; .content{ @include library.changeXY($newX: 4px, $newY: 5px); @include library.common-pad; } 通过 的两种方式的对比，我们可以发现其中用两个mixin来替代一个mixin的方式要灵活一些，这个现象会在随着代码量的增多而变得更加明显！！ 可修改的变量 当我们通过@use来引用一个变量的时候，我们可以访问到这个变量，那么是否也意味着我们可以修改变量的值？ 答案是肯定，但是这对于模块化而言，这种行为是非常⚠️的，也应当被制止，但是有时就是防不慎防，所以，应该要提供一个机制，就是模仿面向类编程所采用的思维，利用private以及protected的保护机制，将需要隐藏的 变量都给保护起来！ 模块加载 在sass中，一般建议将原本一个大的整体样式块进行拆分，然后将基本的作为其他的来使用，这有点像我们在面向对象中的模块化编程，统一对外只有一个入口，所有的访问都通过这个入口来进行访问。 sass提供了一种特殊的模块化机制，称之为：分包，通过分包实现一个入口来访问，并自动加载被依赖的模块，分包采用_*.scss来命名，告知sass不要将该文件进行单独编译，而是作为一个分包 来加载，一般地，比如有以下的代码： // style/fundation/_list.scss .list{ color: yellow; } // style/fundation/_detail.scss .detail{ background-color: blue; } // style/index.scss @use 'fundation/list'; //在fundation目录中的_list.scss @use 'fundation/detail'; //在fundation目录中的_detail.scss :start2: 最佳实践： 结合css变量与sass分包加载逻辑，以及如果加载的是css的话，那么css将会原样输出，这里我们可以使用css变量，做全局控制， 由于加入了css变量，css变量的一个准则是，一旦变动全局影响，那么我们可以根据这个属性特征，来实现动态变换系统主题的功能， 然后利用sass将css变量原样输出，并借助于变量的引用，做到系统全局关联的目的！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-02 06:12:11 像编写Javacript一样来写样式-@use-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@use"},"at-rules/at-forward/readme.html":{"url":"at-rules/at-forward/readme.html","title":"@forward","keywords":"","body":"@forward 转发规则，有点类似于@use规则，但它是主要是用于\"控制组装\"从@use中引入而来的资源模块(变量、混入、函数，本文以下统称资源模块)，简单地理解是@forward可以原封不动地将从@use中引入的资源，直接暴露给下一个forward使用者，或者是加上自己的一个装饰，然后再 暴露给到下一个forward使用者，而且在转发后，使用的导入的模块资源时，必须采用转发者forwarder的命名空间 通过 关于@forward的一个工作过程效果图，我们可以很清楚地理解整个转发的过程！！ // _list.scss @mixin list-reset{ margin: 0; padding: 0; list-style: none; } // forwarder.scss @forward \"list\"; // demo.scss @use \"forwarder\"; li{ @include forward.list-reset } 添加样式前缀 在使用转发的过程中，我们可以通过给@use得到的资源进行样式前缀的追加，由同一份代码来生成不同命名空间下的模块资源(变量、函数、混入)，并且每个引入而来的资源模块，都可以添加统一的前缀， 主要通过：@forward 'library' as -* 的方式，来给导入而来的每一个资源添加统一的前缀 // _list.scss @mixin reset{ margin: 0; padding: 0; list-style: none; } // _bootstrap.scss @forward \"list\" as list-*; // demo2.scss @use \"bootstrap\"; li{ @include bootstrap.list-reset; } 转发控制模块可见性 既然可以使用转发来暴露资源模块，那么应该也是可以通过某种机制，来控制转发的资源模块的可见行： @forward \"library_path\" show/hide 这感觉很像在之前文章中的@use的通过-/_的方式来将资源模块保护起来有点异曲同工之处，虽然写法使用上有区别，但目的是一样的 可配置的转发 转发也是像@use的使用默认配置方式一致，只不过是变成了深层次的转发而已 跟人感觉这个@forward有点鸡肋，使用上基本上都有替代方案，或者有更好的实现机制，目前还未能发现它的一个可用之处～～ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-02 08:48:09 像编写Javacript一样来写样式-@forward-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@forward"},"at-rules/at-import/readme.html":{"url":"at-rules/at-import/readme.html","title":"@import","keywords":"","body":"@import 一个与@use类似、但在不久的见谅将会被铲掉的语法规则！！！ sass中的@import继承了css中的import语句规则，允许从外部引入资源模块(变量、函数、混入)，然后对其进行组合，与普通的css中的import所不同的是： sass中的@import是在编译是完成的，而css中import则是通过http协议来请求加载到资源的； sass中的@import可以通过逗号分割来将要被导入的模块分割并同时加载，而css中的import一次只能导入一个。 官方建议：未来将铲掉@import，原因主要有一下几点： @import使得导入的资源模块变得全局可用，这一点非常的重要，这也是与@use规则所最大的不同点，全局可用，方便资源访问的同时，也会引发对应的问题：增加问题排查的复杂度，因为不知道资源模块在什么时候以及在哪里被定义了，而且没办法给它加上命名空间的前缀，用以区分开来； 假如使用了@extend语句，很难晓得资源是在哪里被继承而来的； 每次@import都是会重新导入，这徒增了代码； 假如想要保护导入的部分资源，用@import是无法实现的。 鉴于上述 提及到的一些场景，后续在使用sass中导入时，尽量采用@use关键词来引入资源模块，假如现有项目使用的@import的话，那么可以使用官方的迁移工具： migration tool，来实现 // _module1.scss @mixin m1 { font-size: 13px; color: yellow; } // _module2.scss @import \"module1\"; @mixin m2 { @include m1; color: blue; font-weight:bold; } // demo1.scss @import \"module1\"; @import \"module2\"; .demo1{ @include m1; @include m2; background-color: green; } 从 我们可以看出关于@import的一个使用，就真的是跟js中的var定义变量的方式类似，对于import进来的资源模块，无需加入模块的命名空间， 这有点让自己在调试的时候，不知道资源模块是在哪里被定义的！ 模块的加载(这与@use一致) 模块的加载 嵌套导入 一般情况下，我们是在样式顶层位置的地方编写导入资源模块的语句，但是我们也可以在嵌套的上下文中来导入，如下所示： // _module.scss @mixin m1 { font-size: 20px; color: blue; } // demo2.scss .header{ //@include m1; -->这里将会报错 } .body{ .content{ // @include m1; -->这里将会报错 } background-color: yellow; @import \"module.scss\"; @include m1; } .footer{ //@include m1; -->这里将会报错 } 这里只有在嵌套的.body作用域下m1才是全局的，在其他模块作用域下，则不是！！ 由于@import可以使用嵌套导入，那么它这里关于父选择器的作用就彰显出来了，如下代码所示： // _module.scss @mixin m1{ font-size: 12px; color: blue; } // demo3.scss .content{ @import \"module\"; .body &{ @include m1; background-color: #2aa198; } & .header{ @include m1; font-size: 30px; } } 与@use的区别 @import中定义的资源模块都是全局的，无需添加命名空间来限定； @import中定义的资源模块将会导致重复定义，因为它是每次导入都使用的； @import一次可导入多个模块，用逗号分割即可； @import导入可以不用引号包裹而直接导入； 支持嵌套导入 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-04 06:33:29 像编写Javacript一样来写样式-@import-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@import"},"at-rules/at-mixin-and-include/readme.html":{"url":"at-rules/at-mixin-and-include/readme.html","title":"@mixin-@include","keywords":"","body":"@mixin与@include @mixin与@include一般成对存在，一个用于定义，一个用于引入。@mixin与其他语言的混入思想一致，旨在提供一套可重复使用的可配置化的样式代码块，其语法规则如下所示： 这里结合了函数与样式而形成的一种新型产物，一般可通过@include来引入，@include的规则会随着@mixin定义时的规则而定，比如传递了参数(或者列表、或者map、或者默认参数)而定，其语法规则如下： @include () // _module.scss @mixin blue-font{ font-size: 24px; color: blue; } // demo1.scss @use 'module'; .content{ @include module.blue-font; } 因为历史原因，有一个点需要注意的是：中横线与下划线所定义的mixin名称，两者代表的是同一个意思！！！ mixin的参数 类似于函数，@mixin允许携带参数，这意味着允许携带参数将样式代码块变成具有逻辑运算能力的样式代码块 // demo2.scss @mixin padding-num ($size){ padding: $size; } .content{ @include padding-num(20px); } 可选的参数 与ES6.0中的函数类似，通过对函数参数进行解构赋值的方式，对@mixin进行参数配置化，意味着这里定义的@mixin中的参数，可以全都传递过来，也可以根据情况进行可选性传递，来达到不同效果的@mixin输出 @mixin optional-argument($size, $radius: 0){ width: $size; height: $size; @if $radius != 0 { border-radius: $radius; } } .content{ @include optional-argument(20px, 10px); } 像map一样的参数 在通过 可选参数的方式来使用@mixin时，也可以通过提供像map中的key*value的方式，来提供无序化传参的机制，比如我们定义了接收 ($1:0,$2:1,$3:2)的方式，然后只想传递其中的$2的值的话，那么可以直接只传递($2:10)的方式，来传递参数，达到无需严格关注每一个参数的位置： @mixin mapArgument($s1: 0, $s2: 0, $s3: 0){ @if $s1 != 0 { padding: $s1; } @if $s2 != 0 { margin: $s2; } @if $s3 != 0 { border-radius: $s3; } } .content{ @include mapArgument($s2: 10px); } 从上面我们可以看出我们定义的@mixin定义了3个参数，然后我们在调用这个mixin的时候，只传递了第二个参数$s2，无需关心这个参数出现在第几个位置，而是只需要关注定义的这个参数的key的名称即可， 大大提高了编写的@mixin的灵活度！！ 可接收任意数量的参数 这与ES6.0中的对象/数组扩展符有些相类似，通过定义传参后，加多一个...标识符的方式，将该参数变量变成一个数组或者是一个可展开的对象，来实现对数组/对象的处理(比如for循环) @mixin spreadArray($argument...){ @for $i from 0 to length($argument){ #{nth($argument, $i + 1)} { position: absolute; margin-top: $i * 100; } } } @include spreadArray(\"input.name\", \"input.address\", \"input.zip\"); 接收一整个对象参数 @use \"sass:meta\"; @mixin spreadObj($argument...){ @debug meta.keywords($argument); @each $name, $color in meta.keywords($argument){ pre span.stx-#{$name}{ color: $color; } } } @include spreadObj( $string: #009, $comment: #812, $variable: #531 ) 像参数一样思考来传递代码块 像参数传递模块一样来思考，@mixin允许将一整块样式代码块通过关键词@content来传递，这样子之后，mixin使用者也可以像参数一样来编写样式代码块了。 @mixin hover{ &:hover{ @content; } } button{ @include hover{ background-color: #2aa198; color: white; } } @content是mixin的mixin，因为mixin原本就是代码块，而@content是代码块的占位符，那么它也可以像@mixin来思考，提供参数的机制， 来生成动态的代码块，语法规则是：定义：@content () 使用：@include () using () { // 代码块 } @mixin media($types...) { @each $type in $types { @media #{$type} { @content($type); } } } @include media(screen, print) using ($type) { h1 { font-size: 40px; @if $type == print { font-family: Calluna; } } } 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-05 05:48:06 像编写Javacript一样来写样式-@mixin-@include-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@mixin-@include"},"at-rules/at-function/readme.html":{"url":"at-rules/at-function/readme.html","title":"@function","keywords":"","body":"@function 与普通的函数一样，@function接收一系列参数，经过内部的逻辑运算处理能力，最终返回目标结果值，看着感觉好像与之前习🉐️的@mixin有点雷同，但他们两者还是 一些区别的： @function的返回值是一个值(sass所支持的数据类型),确切地说，应该是一个右值，而@mixin则是一个样式代码块； @function必须要有@return标志的返回值，一般作为sass属性的样式值； @function无需通过@include进行引用，而是直接调用 @function pow($base, $exponent){ $result: 1; @for $_ from 1 through $exponent { $result: $result * $base; } @return $result; } .sidebar{ float: left; margin-left: pow(4, 3) * 1px; } 在@function中有可能会不小心访问并改变到了全局变量，但是尽量避免这么做，这与咱们平时良好的coding习惯:u6709: 关，任何函数应当是面向接口面呈的，在接收同等参数的情况下，返回的结果应该是一样的，期间不应该会因为改变到了全局变量，而导致的在传递同样参数返回的不同结果，假如真的有这个修改到 全局变量的必要的话，那么尽量是在一开始就完成了这个修改动作，而不是在程序执行过程中来修改！！！ 函数的参数 与@mixin中的参数一致，详见mixin中的参数 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-05 08:32:36 像编写Javacript一样来写样式-@function-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@function"},"at-rules/at-extend/readme.html":{"url":"at-rules/at-extend/readme.html","title":"@extend","keywords":"","body":"@extend 与普通的对象/类的继承思维模式一样，@extend主要用于阐述两个样式选择器之间的一个关联关系：一个作为子类，一个作为父类，子类继承父类的所有属性，还可以在子类中追加自身的额外特殊属性，来完成子类选择器的编写， 其语法规则如下： @extend .error{ border: 1px solid; background-color: #123; &--serious{ @extend .error; color: blue; } } @extend不一定发生在嵌套，对于普通平级或者是孙子选择器的嵌套也同样适用，如下所示： .button{ font-size: 12px; } .x-button{ @extend .button; border: 1px solid red; } 这里推荐使用嵌套是由于 一个团队提出了一个广为业界开发者所认同的一个关于css的命名规范：BEM，而且现有的大部分UI框架都采用了这种命名规范！！！ @extend与@mixin的区别 首先，这两者都是用来封装与重复利用sass样式文件的，但两者有 两点的区别，这将决定了我们在使用的时候优先采用哪个的选择： @mixin允许通过传递参数来进行的动态化样式表，而@extend只能是原样接收； @extend用来表达两个样式选择器之间的父子继承关系，配合BEM命名，可规范化css。 继承的\"限制\" 与java这种面向对象继承一样，@extend只能实现单继承的方式，不允许同时继承多个样式选择器，一次语句只能继承于一个样式选择器， 如下所示： .button{ color: blue; } .mini-button{ font-size: 12px; } .my-button{ @extend .button .info; //这里将会直接报错 background-color: red; } 要同时继承与两个样式选择器的话，只能是一次语句继承于一个选择器，如下所示： .button{ color: blue; } .mini-button{ font-size: 12px; } .my-button{ @extend .button; @extend .mini-button; background-color: red; } 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-07 08:29:06 像编写Javacript一样来写样式-@extend-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@extend"},"at-rules/at-error/readme.html":{"url":"at-rules/at-error/readme.html","title":"@error","keywords":"","body":"@error 与我们平时编写的代码一样，在编写sass语句的时候，同样允许我们可以在验证编码结果的同时，输出某个变量/表达式的值，并输出上下文错误的堆栈信息，语法规则如下： @error 一般可用于某个变量/表达式在使用之前值的一个校验规则，而且一旦执行了该语句时，立马停止继续往下编译， 如下所示： @mixin name($s1){ @if $s1 == null { @error '函数必须要传递@s1'; } font-size: 20px; border-number: $s1; } .content{ @include name(null); } 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-07 08:37:26 像编写Javacript一样来写样式-@error-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@error"},"at-rules/at-warn/readme.html":{"url":"at-rules/at-warn/readme.html","title":"@warn","keywords":"","body":"@warn 与之前的@error使用类似，但 一点不同的是，它不会停止执行脚本编译，而是直接输出警告信息，并继续往下走，这可以在自己平时的关于css库的一些版本升级中提及，提示后续将没有这个逻辑之类的操作 @mixin name($s1){ @if $s1 == null{ @warn \"后续必须要传递这个$s1变量的值\"; } font-size: 30px; color: #2aa198; } .content{ @include name(null); } 从 可以看出@warn并不会停止编译，而是打印出警告的信息以及位置，然后程序继续往下执行！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-07 08:45:17 像编写Javacript一样来写样式-@warn-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@warn"},"at-rules/at-debug/readme.html":{"url":"at-rules/at-debug/readme.html","title":"@debug","keywords":"","body":"@debug @debug作为编程世界中的常客，应该是所有的编程语言中都会 它的一个身影，主要用来输出变量/表达式的值的，其语法规则如下：@debug 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-07 08:47:12 像编写Javacript一样来写样式-@debug-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@debug"},"at-rules/at-at-root/readme.html":{"url":"at-rules/at-at-root/readme.html","title":"@at-root","keywords":"","body":"@at-root 请先看 的一段sass代码： .content{ font-size: 14px; .body{ color: blue; .content{ background-color: yellow; .title{ font-size: 30px; } } } } 从上面可输出css样式结果可以看出，随着嵌套的层次的加深，编译输出的层次将越加越来越多，而且也会慢慢地增加输出的css代码体积 sass提供了一种@at-root的语法规则，可以解决 所遇到的问题，其语法规则如下：@at-root (with/without) { // 样式代码块 }代码如下所示： .content{ font-size: 14px; @at-root .body{ color: blue; @at-root .content{ background-color: yellow; @at-root .title{ font-size: 30px; } } } } 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-07 09:09:04 像编写Javacript一样来写样式-@at-root-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-@at-root"},"at-rules/flow-control/readme.html":{"url":"at-rules/flow-control/readme.html","title":"流程控制","keywords":"","body":"流程控制 在前面学习的关于编写sass的相关代码时，比如@mixin或者@function的时候，其实我们就已经接触关于sass中的流程控制的相关语法语句规则了，正如其他的编程语言一样，它允许通过 @if来判断是否执行某个代码块，@each来遍历list或者map对象中的每一个值，@for来循环执行一定次数逻辑代码，@while来执行知道条件不 足为止！下面将一一介绍每个\"艾特流程控制\"语法的使用 @if与@else 语法规则：@if {...} @else if {...} @else@if一般与@else成对存在，与其他的编程语言类似，允许有多个不同的条件判断逻辑同时存在，通过真值与假值的判断，匹配执行对应的逻辑代码块 // at_if.scss @mixin name($xxx) { @if $xxx != null { font-size: 14px; background-color: #fff123; }@else { font-size: 26px; background-color: #455212; } } .content1{ @include name(#123); } .content2{ @include name(null); } @each 语法规则：@each | , in {...} 一般可用来生成由一个表达式结果(list/map)中的变量控制生成的可重复的样式代码，若表达式的是一个普通的list，则采用一个变量来作为每次迭代的值的存储，若表达式是一个map对象，则使用2个变量分别作为key与value来代表每次的迭代器 // at_each.scss @mixin eachList($list){ @if $list == null { @error \"请传递对应的待迭代的数组对象\"; } @each $item in $list { font-size: $item; background-color: blue; } } @mixin eachMap($map){ @if $map == null { @error \"请传递对应的待遍历的键值对对象\"; } @each $key, $value in $map{ #{$key}: $value; background-color: yellow; } } .list{ $list: 12px, 14px, 16px, 18px; @include eachList($list); } .map{ $map: \"font-size\" 12px, \"font-size\" 14px, \"font-size\" 16px; @include eachMap($map); } 当待遍历的表达式是一个二维的数组的情况下的话，它是否也能够🉐️到变量的替代与遍历呢？答案是肯定的， 采用一个二维的4孩子数组的方式来具体说明情况： // at_five_each.scss @mixin fiveEach($list){ @if $list == null { @error \"请传递对应的待迭代的数组对象\"; } @each $firstV, $secondV, $thirdV, $fourthV, $fivethV in $list { #{$fivethV} { font-size: $firstV; color: $secondV; background-color: $thirdV; border-radius: $fourthV; } } } .content{ $list: 12px #123 white 4px firstNode, 13px #643 blue 2px secondNode, 14px #cb4 yellow 3px thirdNode; @include fiveEach($list); } @for 语法规则：@for from to/through {...} 用于向上/向下遍历表达式，遍历的过程采用to/through来决定是否要将终止值参与遍历，to表示终止值不参与，而through表示终止值参与遍历 // at_for_to.scss @mixin forTo(){ @for $item from 1 to 3 { node-#{$item}{ border-radius: #{$item}px; } } } .content{ @include forTo(); } // at_for_through.scss @mixin forThgough(){ @for $item from 1 through 3 { node-#{$item}{ border-radius: #{$item}px; } } } .content{ @include forThgough(); } while 语法规则：while {...}用于循环执行一个代码块，当变量表达式为假值的时候停止遍历 // @while.scss @mixin name($val){ @while $val > 0 { @debug \"开始来遍历元素了\"; .item-#{$val}{ font-size: 10px * $val; border-radius: #{$val}px; } $val: $val - 1; } } @include name(3); 实际在编码过程中，尽量采用@each或者@for来实现@while的效果，这是因为这样子做的话，可以提升sass编译的速度！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-12 10:03:52 像编写Javacript一样来写样式-流程控制-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-流程控制"},"at-rules/from-css/readme.html":{"url":"at-rules/from-css/readme.html","title":"与css的兼容","keywords":"","body":"与css的兼容 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-06-25 16:09:51 像编写Javacript一样来写样式-与css的兼容-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-与css的兼容"},"values/readme.html":{"url":"values/readme.html","title":"数据类型","keywords":"","body":"数据类型 sass结合了css以及js的数据类型，因为它既 css的表现方式，也 js中的数据类型的展现形式，在sass中一般是用 变量来存储对应的数据，一般在sass中有以下图的数据类型： Numbers sass中的Numbers可以由两部分组成：数字 + 单位，Numbers类型的变量，它可以 单位，也可以没有单位，具体按照实际情况进行处理，比如 以下场景： // index.scss @debug 100; @debug 0.5; @debug 16px; @debug 5px * 5px; Numbers更贴近生活 可以从 例子的最后一个输出25px*px，这有点类似于数学应用中的平方px，也就是说sass中的单位更具有实际的意义，它能够模拟到真实世界中的 关于单位的实际应用场景，比如平方、立方、千米每小时等等，如下所示： // index2.scss @use 'sass:math'; @debug math.div(10px, 2s); @debug 5px * math.div(math.div(30deg, 2s), 24em); $degrees-per-second: math.div(20deg, 1s); @debug $degrees-per-second; @debug math.div(1, $degrees-per-second); 从 我们可以看出sass中的单位与真实世界中的数学应用是能够完全对应上的，这里有一个点需要 的是：既然sass中的单位在真实世界中是 关联的，那么是否可以直接将它给输出到css呢？答案是不可以的，如果直接输出到css中的话，将会导致程序的报错了，那么这个功能是不是很鸡肋呢？ 提供了一个复杂单位的数学运算，然后其结果不能用来用到实际的场景？答案肯定不是的，:stars: 我们可以用它来做与数学应用实际相关联的逻辑运算，并在最后输出css能够识别到的样式代码。 // index3.scss @use 'sass:math'; $transition-speed: math.div(1s, 50px); //1/50s每px @mixin move($left-start, $left-stop){ position: absolute; left: $left-start; transition: left ($left-stop - $left-start) * $transition-speed; &:hover{ left: $left-stop; } } .slider{ @include move(10, 120px); } 一般很难精准计算出目标结果，可以结合复杂单位运用到实际场景中，从侧面来计算出对应的目标结果值！！！ 如果一个变量有单位，另外一个变量没有单位，那么两者是否一致呢？ 答案是否定的，虽然sass中的数值中的单位是可选的，但是它两者代表的是不同的 // index4.scss @debug 10 == 10px; @debug 10px == 10; sass中的关于math.div除法运算，它不想其他的编程语言(比如java)，它在执行的过程中，不会因为除数与被除数的关系，而使结果仅保留整数部分， 它会按照实际场景保留对应的小数部分！！！ 在sass中 一种比较特殊的场景，就是同个\"领域\"下的数据类型，将会发生自动转换，转换的过程，根据实际情况而定，如下所示： @debug 30px + 2; @debug 5s + 50ms; @debug 3em + 3; 从 可以看出: 不带单位的数据，将会被自动转换为 对应单位的一个数学运算结果，那么假如两个都是长度尺寸单位下的运算的话，又会发生怎样的一个情况呢 将会直接报错，停止运行了，如下图所示： Colors sass中的关于颜色数据类型，完全来自于css中的css颜色数据类型： 具有特定意义的颜色值：blue、red、green； 十六进制颜色值：#112233； 颜色函数：rgb()或者rgba()或者hsl()或者hsla(); Strings sass中的字符串，🉑️由引号包裹起来，也可以不由引号包裹，两者之间可以进行一个互相转换(借助于sass:string所提供的一公共api)。 一般来说，带引号与不带引号的字符串两者没有什么区别，一般sass在执行的过程中将会自动进行转换，但是假如 的一些情况下，sass将不会自动进行转换： css颜色名称(比如blue、green、red等)，它只会转换为对应的Color数据类型； null数据类型，只会转换为对应的null数据类型； true/false，只会转换为对应的真值/假值； and、or、not，只会转换为对应的与或非； 从 我们可以得出在日常coding过程中，是字符串类型的数据统一采用引号来包裹起来，而不是直接交给sass去做自动转换，这样子可以避免一些不必要的 未知异常的发生，给自己写bug！！！ Booleans sass中的Booleans数据与js中的Boolean基本数据类型一致，通过提供的真/假来与其他的判断、循环语句进行结合，实现代码块的按需(真/假)来执行。 主要由 几种结合方式： 与@if条件判断的结合； 与逻辑与或非(and、or、not)的结合； 与三目运算符if的结合； 与@while循环的结合； List 与其他的编程语言所不同的是，sass中的数组类型的数据，由空格、逗号分割而形成一数组，无需额外使用其他标志符， 一个List数组可以包含有0个或者以上任意数量的孩子元素，一个数组的常规表达式语法如下所示： , 或者[]而空数组，则可以由()或者[]来表示 建议在日常的coding过程中，采用[]来表示一个空数组，这里采用这种方式，主要是为了与 的Map混淆了！！！ 像js中的数组一样来使用sass中的List 一个数组List，必然 对应的一系列操作，不然就只是单纯的进行数据的存储而已，而对于List， 几种方式来使用List来服务于自己的程序： 下标的访问：indexes，与其他任何一门编程语言所不同的是，sass中List的下标是从1开始算起的，而且如果负数的话，则代表从尾部算起； 数组元素的访问：list.nth($list, $index)，通过给定的下标来访问数组的元素； 数组元素的遍历：@each $item in $list，与@each艾特规则结合，来遍历数组中的每一个元素； 数组元素的追加：list.append($list, $item)，通过在数组尾部追加一个新的孩子元素，返回出一个新的数组； 数组元素的查找：list.index($list, $item)，返回出查找到的元素的下标 针对上述几种情况，这边统一以一个例子来阐述对应的使用： // index7.scss @use \"sass:list\"; $list: 'AA', 'BB', 'CC', 'DD', 'EE'; @debug \"原始数组为：\"+$list; @debug \"这个数组的长度为\"; @debug \"数组的第三个元素是：\" + list.nth($list, 3); @debug \"下面针对该数组进行生成对应节点样式的输出：\"; @each $item in $list { .node-#{$item} { background-color: \"#1\"+#{$item}; &:after{ content: $item; } } } $newList: list.append($list, 'FF'); @debug \"追加元素后的数组是：\" + $newList; @debug \"FF是否存在于原本的数组中：\" + list.index($list, 'FF'); @debug \"FF是否存在于新的数组中：\" + list.index($newList, 'FF'); 从 我们可以看出原数组在被append后，是返回了一个新的操作后的数组，而原来的数组则保持不变！！！ Map sass中的Map与js中的对象字面量相类似，只不过sass中的Map所不一样的是它是由()来包裹起来的，都是由不同的 key+value，都逗号分割来组成的，每一个key都可以由不同类型的数据来组成，但是在实际的coding过程中，应当尽量采用 具有对应意义的字符串来作为key，这个是为了编写他人能够看得懂的、可维护的代码。 在表示一个 对象的时候，虽然可以采用 []或者()来表示，但是尽量是采用()来表示，为了与 的 数组给区分开来，目的也都是为了更加方便的进行代码阅读与维护！！！ 像Java中的Map对象一样来使用Map 与List类似，sass中的sass它也提供了一系列的API操作，来方便我们进行逻辑的编写 值的获取: map.get($map, $key)，获取一个对象中key所对应的值； 内容遍历: @each $key, $value in $map，通过@each加上传递的$key与$value代表，来遍历一个对象； 追加元素：map.set($map, $key, $value)，给对象加上一对属性值，如果$key原本存在，则覆盖掉原来的属性所对应的值； 对象的合并：map.merge($map1, $map2)，合并两个对象，并返回一个新的对象，在合并过程中若$map2中由key存在于$map1中，则使用后者的值来覆盖前者的值 针对上述的情况，这边统一整理以下的一个例子来阐述如何使用sass中的Map // index8.scss @use \"sass:map\"; $map: ('font-size': 12px, 'border-radius': 3px, 'color': '#ff3320'); @debug \"原对象为：\"; @debug $map; @debug \"border-radius的值为：\" + map.get($map, 'border-radius'); @debug \"以下开始遍历对象中的所有属性与值!!\"; @each $key, $value in $map { .content{ #{$key}: $value; } } @debug \"即将给元素追加一属性值：font-wight: bold\"; @debug map.set($map, 'font-weight', bold); @debug \"追加元素后的对象为：\"; @debug $map; $map2: ('background-color': red, 'font-size': 20px); @debug \"即将使用新的对象和组合成新的对象\"; $map3: map.merge($map, $map2); @debug \"组合后的对象为：\" ; @debug $map3; Calculations > Functions Null 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-15 20:08:16 像编写Javacript一样来写样式-数据类型-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-数据类型"},"operators/readme.html":{"url":"operators/readme.html","title":"操作符","keywords":"","body":"操作符 sass中存在由变量，则意味着它可以有连接并计算两个变量值的操作符，与js类似，sass也提供着一系列的用于处理不同值 之间的操作符，像加减乘除、逻辑与或非等，sass中的操作符主要有以下几大类： 对比两个值是否相等: ==与!=； 正常的数学运算：+、-、x、math.div、%； 大小比较：>、=、 逻辑操作：and、or、not； 字符串连接符：+、-； 关于字符串连接符，两者都是用来连接两个字符串的，但是它们之间 一个明显的区别，就是+仅做单纯的连接，而-则是一同参与作为输出内容的连接操作符！！！ 对于逻辑与或非，它们与其他的编程语言所不同的是，它们采用的是英文单词来表示的！！！ 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-19 05:44:46 像编写Javacript一样来写样式-操作符-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-操作符"},"build-in-modules/readme.html":{"url":"build-in-modules/readme.html","title":"预设库","keywords":"","body":"预设库 sass中提供了一些库函数以及mixin来给使用者直接调用，比如想要操作/访问List数组对象，则可以使用@use 'sass:list'，然后通过list.append($list, $item)的方式来使用，这里有点像平时使用的全局静态API，用sass作为前缀，代表它是sass所提供的 在sass中也存在着那么的一些函数(像if()、var())，它们无需被导入@use ...的方式来使用，而是直接使用，这个是由于历史的语法规则原因，而且后来用着也比较爽，因此官方也就没有废弃掉这种语法规则！ 针对不同的数据类型，sass提供了一系列相关的API库来供使用！！！如下图： 具体的每个api的使用方式，详见官方的说明文档 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-19 06:01:11 像编写Javacript一样来写样式-预设库-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-预设库"},"sass-in-boostrap/readme.html":{"url":"sass-in-boostrap/readme.html","title":"sass在bootstrap中的使用","keywords":"","body":"sass在bootstrap中的使用 在学习完成了关于sass的相关知识点，回到最初的原点来提问：sass可以用来做什么？如何使用sass？ 在学习了bootstrap的源码之后，借鉴于sass在它里面的一个使用，这边整理了以下几个要点，可供自己平时在日常项目coding 过程中，更好地来设计css，编写更加灵活简便的sass script来维护系统，以便于更加灵活的控制自己的系统/组件库！！！ 一切以统一的入口开始 这有点类似于webpack中的entry入口，从入口开始，一个依赖一个，最终发散成为一棵 ，这里借助于sass中的模块导入的方式，采用@import _xxx的方式，让每一个子模块仅作为其子模块参与编译即可！ 应用实战 通过借鉴于sass在bootstrap中的一个使用情况，这边参考其设计原理，进行一个模仿设计，并从中得出以下几点，帮助自己在实际的 项目设计开始阶段进行一个全局的设计，为后续灵活扩展做好基础工作： 1. 变量的统一管理(_variable.scss) 作为系统中全局变量，提供整个系统(或组件库)的统一配置化参数，对所有的参数统一采用!default标志代表所有的参数都是允许被配置的， 当在使用这些变量的时候，允许通过重载变量，来实现用户自定义配置的目的； 2. 变量的分模块管理 可针对 中的_variable.scss中所出现的变量进行分模块管理，建议可采用不同的注释模块来进行维护管理； 3. 变量配置基准数据源 作为其他各个模块待引用的基准数据源(可以是对象、数组)，然后其他的模块依赖此配置化参数，针对基准数据源做一个二次封装的机制， 生成对应场景下的样式组合 4. _root的全局配置 配合css变量，将所有的css变量与_variable.scss中的变量配合，形成全局的css变量，可用整个系统去直接访问 5. 衍生其他模块 将统一的变量作为基准配置，作为数据源，提供给_function.scss、_mixin.scss、_reboot.scss以及其他组件模块的被依赖对象， 根据实际应用场景，拆分为不同的功能板块 91temaichang.com®前端开发者、APP开发工程师、架构师、项目管理Copyright © 郑耿林 all right reserved最新更新于 2022-07-19 23:47:46 像编写Javacript一样来写样式-sass在bootstrap中的使用-zhenggl zhenggl, sass, scss, css, style, 郑耿林 像编写Javacript一样来写样式-sass在bootstrap中的使用"}}